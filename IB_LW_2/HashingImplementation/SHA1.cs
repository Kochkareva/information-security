using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;

namespace IB_LW_2.HashingImplementation
{
    public static class SHA1
    {
        static uint h0 = 0x67452301;
        static uint h1 = 0xefcdab89;
        static uint h2 = 0x98badcfe;
        static uint h3 = 0x10325476;
        static uint h4 = 0xc3d2e1f0;

        static byte[][] blocks;

        public static uint ROTL(uint original, int bits)
        {
            /*
             * выполняется сдвиг битов числа original влево на bits позиций, затем 
             * выполняется сдвиг битов числа original вправо на 32 - bits позиций.
             * Затем результаты сдвигов объединяются с помощью побитовой операции ИЛИ (|).
             */
            return (original << bits) | (original >> (32 - bits));
        }

        static void Initialization(byte[] message)
        {
            // Вычисляем iter - количество блоков, на которое будут разбиваться данные
            // Необходимо разбивать блоки по 512 бит = 64 байта
            // Используем Math.Ceiling для округления вверх, чтобы учесть случай, когда длина сообщения не делится нацело на 64
            int iter = (int)Math.Ceiling((double)message.Length / 64);
            // Вычисляем количество свободных байтов в последнем блоке, которые необходимо заполнить
            int freebytes = iter * 64 - message.Length;

            // Проверяем, достаточно ли свободных байтов, чтобы добавить информацию в блок
            // Необходим 1 байт, после которого в 8 байт записывается длина исходного сообщения в битах
            if (freebytes >= 9)
            {
                //  Создаем двумерный массив массивов blocks с количеством строк = iter, где каждый элемент представляет отдельный блок.
                blocks = new byte[iter][];
            }
            else
            {
                throw new NotImplementedException();
            }

            // Цикл для каждого блока
            for (int ind = 0; ind < iter; ind++)
            {
                // Создаем новый блок с длиной 64 байта = 512 бит
                blocks[ind] = new byte[64];

                // Проверяем, является ли текущий блок последним, и проверяем наличие остатка от деления длины исходного сообщения на 64.
                if (ind + 1 == iter && message.Length % 64 != 0)
                {
                    // Заполняем блок данными из сообщения, исключая свободные байты для хранения исходной длины сообщения.
                    for (int i = 0; i < blocks[ind].Length - freebytes; i++)
                    {
                        blocks[ind][i] = message[i + ind * 64];
                    }

                    // Добавляет бит "1" в конец блока, используя сдвиг влево для установки самого старшего бита.
                    blocks[ind][blocks[ind].Length - freebytes] = (byte)1 << 7;

                    // Создаем массив байтов, представляющий длину исходного сообщения (умноженную на 8), с помощью
                    // метода Converter.LongToByteArray - для преобразования числового значения типа long в его двоичное представление в виде массива байтов
                    byte[] length = Converter.LongToByteArray((long)message.Length * 8);

                    // Добавляем длину исходного сообщения в последний блок, начиная с конца блока.
                    for (int i = 0; i < length.Length; i++)
                    {
                        blocks[ind][blocks[ind].Length - length.Length + i] = length[i];
                    }

                    break;
                }

                // Заполняем блок данными из сообщения, если он не последний
                for (int i = 0; i < blocks[ind].Length; i++)
                {
                    blocks[ind][i] = message[i + ind * 64];
                }
            }
        }

        public static byte[] SHA(byte[] message)
        {
            Initialization(message);

            h0 = 0x67452301;
            h1 = 0xefcdab89;
            h2 = 0x98badcfe;
            h3 = 0x10325476;
            h4 = 0xc3d2e1f0;
            
            // Цикл for для каждого блока в массиве blocks
            for (int i = 0; i < blocks.Length; i++)
            {
                // Создаем массив W длиной 80, который будет использоваться для хранения сообщения, т.е.
                // происхожит расширение 16 32-битовых слов Mi (блока размером 512 бит) в 80 32-битовых слов 
                uint[] W = new uint[80];

                for (int t = 0; t < W.Length; t++)
                {
                    if (t <= 15)
                    {
                        // Создаем массив word длиной 4 байта (т.е. 32 бит)
                        byte[] word = new byte[4];
                        // Каждый элемент word заполняем значениями из текущего блока по формуле 
                        for (int ind = 0; ind < word.Length; ind++)
                        {
                            // значение элемента массива word на позиции ind равно значению элемента из текущего блока + t * 4,
                            // где t - текущая позиция в массиве W
                            // берется 4-байтовое слово из текущего блока сообщения и конвертируется
                            // в 32-битное беззнаковое целое число, которое сохраняется в соответствующей ячейке массива W.
                            word[ind] = blocks[i][ind + t * 4];
                        }
                        // Полученное массив word преобразовываем из массива байтов в беззнаковое целое число и записываем в массив W
                        W[t] = Converter.ByteArrayToUInt(word);
                    }
                    else
                    {
                        // ^ - обозначает побитовое исключающее ИЛИ
                        // вычисляем текущее значение W[t] на основе предыдущих элементов массива W.
                        // берем значение третьего элемента перед текущим элементом, значение восьмого элемента перед текущим элементом,
                        // значение четырнадцатого элемента перед текущим элементом, значение шестнадцатого элемента перед текущим элементом.
                        // Затем мы выполняем операцию побитового исключающего ИЛИ (^) между этими четырьмя значениями
                        // и применяем операцию циклического сдвига влево
                        W[t] = ROTL(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);
                    }
                }
                // инициализируем переменные a, b, c, d, e значениями h0, h1, h2, h3, h4 соответственно. 
                uint a = h0;
                uint b = h1;
                uint c = h2;
                uint d = h3;
                uint e = h4;

                for (int t = 0; t < 80; t++)
                {
                    // вычисляем значение T, применяя операцию циклического сдвига влево для значения a на 5 позиций,     
                    uint T = ROTL(a, 5);
                    // добавляем значение функции, которое зависит от t
                    if (t >= 0 && t <= 19)
                        T += ((b & c) ^ (~b & d));

                    if (t >= 20 && t <= 39)
                        T += b ^ c ^ d;

                    if (t >= 40 && t <= 59)
                        T += (b & c) ^ (b & d) ^ (c & d);

                    if (t >= 60 && t <= 79)
                        T += b ^ c ^ d;
                    // добавляем значение e,
                    T += e;
                    // добавляем значение константы, которая зависит от t
                    if (t >= 0 && t <= 19)
                        T += 0x5a827999;

                    if (t >= 20 && t <= 39)
                        T += 0x6ed9eba1;

                    if (t >= 40 && t <= 59)
                        T += 0x8f1bbcdc;

                    if (t >= 60 && t <= 79)
                        T += 0xca62c1d6;

                    // добавляем значение из массива W по индексу t
                    T += W[t];

                    e = d;
                    d = c;
                    // для получения значения с применяем операцию циклического сдвига влево для значения b на 30 позиций.
                    c = ROTL(b, 30);
                    b = a;
                    a = T;
                }

                // значения a, b, c, d, e добавляем к соответствующим переменным h0, h1, h2, h3, h4
                h0 += a;
                h1 += b;
                h2 += c;
                h3 += d;
                h4 += e;
            }
            // возвращаем хэш-код сообщения, который представляет собой массив байт, полученный из значений h0, h1, h2, h3, h4.
            return Converter.UIntArrayToByteArray(new uint[] { h0, h1, h2, h3, h4 });
        }
    }
}
